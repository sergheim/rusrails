h1. Сессии

Начнем обзор безопасности с сессий, которые могут быть уязвимыми к определенным атакам.

h4. Что такое сессии?

NOTE: _HTTP это протокол, независимый от предыдущих запросов. Сессии добавляют эту зависимость._

Большинству приложений необходимо следить за определенным состоянием конкретного пользователя. Это может быть содержимым корзины товаров или id залогиненного пользователя. Без идеи сессии пользователю нужно идентифицироваться, а возможно и аутентифицироваться, с каждым запросом. Rails создаст новую сессию автоматически, если новый пользователь получит доступ к приложению. Он загрузит существующую сессию, если пользователь уже пользовался приложением.

Сессия обычно состоит из хэша значений и id сессии, обычно 32-символьной строкой, идентифицирующего хэш. Каждый куки, посланный браузеру клиента, включает id сессии. И с другой стороны: пошлет его серверу с каждым запросом от клиента. В Rails можно сохранять и получать значения, используя метод session:

<ruby>
session[:user_id] = @current_user.id
User.find(session[:user_id])
</ruby>

h4. Id сессии

NOTE: _Id сессии это 32-байтное хэшированное значение MD5._

Id сессии состоит из хэшированного значения случайной строки. Случайная строка это текущее время, случайное число от 0 до 1, номер id процесса интерпретатора Ruby (также базирующегося на случайном числе) и строка-константа. В настоящее время не представляется возможным брутфорсить id сессии Rails. В настоящее время MD5 применяется бескомпромиссно, но он имеет коллизии, поэтому теоретически возможно создание разных строк результата с одинаковым хэшированным значением. Но это не влияет на безопасность на сегодняшний день.

h4. Похищение сессии

WARNING: _Воровство id пользовательской сессии позволяет злоумышленнику использовать веб приложение от лица жертвы._

Многие веб приложения имеют такую систему аутентификации: пользователь предоставляет имя пользователя и пароль, веб приложение проверяет их и хранит id соответствующего пользователя в хэше сессии. С этого момента сессия валидна. При каждом запросе приложение загрузит пользователя, определенного user id в сессии, без необходимости новой аутентификации. Session id в куки идентифицирует сессию.

Таким образом, куки служит как временная аутентификация для веб приложения. любой, кто воспользовался куки от кого-то другого, может пользоваться веб приложением, как этот пользователь – с возможными серьезными последствиями. Вот несколько способов похищения сессии и контрмеры этому:

* Перехват куки в незащищенной сети. Беспроводная LAN может быть примером такой сети. В незашифрованной беспроводной LAN очень легко прослушивать трафик всех присоединенных клиентов. Это одна из причин не работать из кафе. Для создателя веб приложений это означает, что _(highlight)необходимо предоставить безопасное соединение через SSL_. В Rails 3.1 и позже это может быть выполнено с помощью принуждения к соединению SSL в файле конфигурации приложения:

<ruby>
config.force_ssl = true
</ruby>

* Многие не очищают куки поле работы на публичном терминале. Поэтому, если предыдущий пользователь не вышел из веб приложения, вы сможете его использовать как этот пользователь. Обеспечьте пользователя _(highlight)кнопкой выхода_ в веб приложении, и _(highlight)сделайте ее заметной_.
* Часто межсайтовый скриптинг (XSS) ставит целью получение куки пользователя. "Подробнее о XSS":/ruby-on-rails-security-guide/injection#cross-site-scripting-xss вы прочитаете позже.
* Вместо похищения неизвестных злоумышленнику куки, он изменяет идентификатор сессии пользователя (в куки) на известный ему. Об этих так называемых фиксациях сессии вы прочитаете позже.

Основная цель большинства злоумышлеников это сделать деньги. Подпольные цены за краденную банковскую учетную запись варьируются в пределах $10–$1000 (в зависимости от доступной суммы средств), $0.40–$20 за номер кредитной карточки, $1–$8 за аккаунт онлайн аукциона и $4–$30 за пароль от email, в соответствии с "Symantec Global Internet Security Threat Report":http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf.

h4. Указания по сессии

Вот несколько общих указаний по сессиям.

* _(highlight)Не храните большие объекты в сессии_. Вместо этого следует хранить их в базе данных и сохранять в сессии их id. Это позволит избежать головной боли при синхронизации и не будет забивать место хранения сессии (в зависимости от того, какое хранение сессии было выбрано, смотрите ниже). Также будет хорошо, если вы вдруг измените структуру объекта, а старые его версии все еще будут в куки некоторых клиентов. Конечно, при хранении сессий на сервере вы сможете просто очистить сессии, но при хранении на клиенте это сильно помогает.
* _(highlight)Критические данные не следует хранить в сессии_. Если пользователь очищает куки или закрывает браузер, они потеряются. А в случае хранения сессии на клиенте, пользователь сможет прочесть данные.

h4. Хранение сессии

NOTE: _Rails предоставляет несколько механизмов хранения для хэшев сессии. Наиболее важным является +ActionDispatch::Session::CookieStore+._

Rails 2 представил новый способ хранения сессии по умолчанию, CookieStore. CookieStore сохраняет хэш сессии прямо в куки на стороне клиента. Сервер получает хэш сессии из куки, и устраняется необходимость в id сессии. Это значительно увеличивает скорость приложения, но является спорным вариантом хранения, и вы должны подумать об условиях безопасности этого:

* Куки предполагают ограничение размера в 4kB. Это нормально, так как не нужно хранить большие объемы данных в сессии, о чем писалось ранее. _(highlight)Хранение id пользователя в сессии это обычно нормально_.
* Клиент может увидеть все, что вы храните в сессии, поскольку они хранятся чистым текстом (фактически кодированы Base64, но не зашифрованы). Поэтому, разумеется, _(highlight)вы не захотите хранить тут секретные данные_. Для предотвращения фальсификации хэша сессии, из сессии рассчитывается дайджест с помощью серверного секретного ключа, и вставляется в конец куки.

Это означает, что безопасность такого хранения основывается на этом секретном ключе (и на алгоритме хеширования, который по умолчанию SHA512, не являющийся пока скомпрометированным). Поэтому _(highlight)не используйте банальный секретный ключ, т.е. слово из словаря, или короче 30 символов_. Поместите секретный ключ в Ваш environment.rb:

<ruby>
config.action_dispatch.session = {
  :key    => '_app_session',
  :secret => '0x0dkfj3927dkc7djdh36rkckdfzsg...'
}
</ruby>

Имеются, тем не менее, производные от CookieStore, которые шифруют хэш сессии так, что клиент не может видеть ее.

h4. Атаки воспроизведения для сессий CookieStore

NOTE: _Другой тип атак, которого следует опасаться при использовании CookieStore, это атака воспроизведения (replay attack)._

Она работает подобным образом:

* Пользователь получает кредит, сумма сохраняется в сессию (что является плохой идеей в любом случае, но мы воспользуемся этим для целей демонстрации).
* Пользователь покупает что-либо.
* Его новый, уменьшившийся кредит сохраняется в сессии.
* Темная сторона пользователя заставила его взять куки с первого шага (которые он предварительно скопировал) и заменить текущие куки в браузере.
* Пользователь получил свой кредит назад.

Включение поля nonce (случайное значение) в сессию решает проблему атак воспроизведения. Поле nonce валидно только один раз, и сервер должен отслеживать все валидные nonce. Такое становится еще более сложным, если у вас несколько серверов приложений (mongrels). Хранение nonce в таблице базы данных аннулирует основную цель CookieStore (избежание доступа к базе данных).

Лучшее _(highlight)решение против атак это хранить данные такого рода не в сессии, а в базе данных_. В нашем случае храните величину кредита в базе данных, а logged_in_user_id в сессии.

h4. Фиксации сессии

NOTE: _Кроме кражи id сессии пользователя, злоумышленник может исправить id сессии на известный ему. Это называется фиксацией сессии._

!/assets/guides/session_fixation.png(Фиксация сессии)!

Эта атака сосредоточена на id сессии пользователя, известному злоумышленнику, и принуждению браузера пользователя использовать этот id. После этого злоумышленнику не нужно воровать id сессии. Вот как эта атака работает:

# Злоумышленник создает валидный id сессии: он загружает страницу авторизации веб приложения, где он хочет исправить сессию, и принимает id сессии в куки из отклика (смотрите номера 1 и 2 на изображении).
# Он по возможности поддерживает сессию. Сессии со сроком дейстивя, к примеру 20 минут, значительно сокращает временные рамки для атаки. Поэтому он обращается к веб приложению время от времени, чтобы сохранить сессию действующей.
# Теперь злоумышленник должен заставить браузер пользователя использовать этот id сессии (смотрите номер 3 на изображении). Поскольку нельзя изменить куки другого домена (из-за политики общего происхождения), злоумышленник должен запустить JavaScript из домена целевого веб приложения. Инъекция кода JavaScript в приложение с помощью XSS завершает эту атаку. Вот пример: +&lt;script&gt; document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9"; &lt;/script&gt;+. Про XSS и инъекции будет написано позже.
# Злоумышленник заманивает жертву на зараженную страницу с кодом JavaScript. Просмотрев эту страницу, браузер жертвы изменит id сессии на id сессии-ловушки.
# Так как новая сессия-ловушка не использовалась, веб приложение затребует аутентификации пользователя.
# С этого момента жертва и злоумышленник будут совместно использовать веб приложение с одинаковой сессией: сессия станет валидной и жертва не будет уведомлена об атаке.

h4. Фиксации сессии - контрмеры

TIP: _Одна строка кода защитит вас от фиксации сессии._

Наиболее эффективная контрмера это _(highlight)создавать новый идентификатор сессии_ и объявлять старый невалидным после успешного входа. Тогда злоумышленник не сможет использовать подмененный идентификатор сессии. Это также хорошая контрмера против похищения сессии. Вот как создать новую сессию в Rails:

<ruby>
reset_session
</ruby>

Если используете популярный плагин RestfulAuthentication для управления пользователями, добавьте reset_session в экшн SessionsController#create. Отметьте, что это удалит любые значения из сессии, _(highlight)поэтому необходимо передать их в новую сессию_.

Другой контрмерой является _(highlight)сохранение специфичных для пользователя свойств в сессии_, проверка их каждый раз с входящим запросом и запрет доступа, если информация не соответствует. Такими свойствами могут быть удаленный адрес IP или агент пользователя (имя веб браузера), хотя последний менее специфичен. При сохранении адреса IP вы должны понимать, что имеется большое количество интернет провайдеров или больших организаций, размещающих своих пользователей за прокси. _(highlight)Адрес может меняться в течении сессии_, поэтому такие пользователи не смогут использовать ваше приложение, либо только с ограничениями.

h4. Окончание сессии

NOTE: _Сессии, которые не имеют время жизни, растягивают временной период для атак, таких как подделка межсайтовых запросов (CSRF), похищение сессии и фиксация сессии._

Один из способов это установить временную метку окончания куки с id сессии. Однако клиент может редактировать куки, хранящиеся в веб браузере, поэтому сессии со сроком действия безопаснее хранить на сервере. Вот пример как _(highlight)окончить сессии в таблице базы данных_. Вызовите +Session.sweep("20m")+ чтобы окончить сессии, которые использовались более 20 минут назад.

<ruby>
class Session < ActiveRecord::Base
  def self.sweep(time = 1.hour)
    if time.is_a?(String)
      time = time.split.inject { |count, unit| count.to_i.send(unit) }
    end

    delete_all "updated_at < '#{time.ago.to_s(:db)}'"
  end
end
</ruby>

Раздел о фиксации сессии представил проблему поддержки сессий. Злоумышленник, поддерживающий сессию каждые пять минут, будет поддерживать срок жизни сессии вечно, хотя у сессии и есть срок действия. Простым решением для этого может быть добавление столбца created_at в таблицу sessions. Теперь можете удалять сессии, которые были созданы очень давно. Используйте эту строку в вышеупомянутом методе sweep:

<ruby>
delete_all "updated_at < '#{time.ago.to_s(:db)}' OR
  created_at < '#{2.days.ago.to_s(:db)}'"
</ruby>
