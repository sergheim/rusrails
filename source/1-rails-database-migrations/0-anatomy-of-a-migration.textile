h1. Анатомия миграции

Прежде чем погрузиться в подробности о миграциях, вот небольшие примеры того, что вы сможете сделать:

<ruby>
class CreateProducts < ActiveRecord::Migration
  def up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def down
    drop_table :products
  end
end
</ruby>

Эта миграция добавляет таблицу +products+ со строковым столбцом +name+ и текстовым столбцом +description+. Первичный ключ, названный +id+, также будет добавлен по умолчанию, поэтому его не нужно определять явно. Столбцы временных меток +created_at+ и +updated_at+, которые Active Record заполняет автоматически, также будут добавлены. Откат этой миграции очень прост, это удаление таблицы.

Миграции не ограничены изменением схемы. Можно использовать их для исправления плохих данных в базе данных или заполнения новых полей:

<ruby>
class AddReceiveNewsletterToUsers < ActiveRecord::Migration
  def up
    change_table :users do |t|
      t.boolean :receive_newsletter, :default => false
    end
    User.update_all :receive_newsletter => true
  end

  def down
    remove_column :users, :receive_newsletter
  end
end
</ruby>

NOTE. Есть некоторые "оговорки":/rails-database-migrations/using-models-in-your-migrations в использовании моделей в ваших миграциях.

Эта миграция добавляет столбец +receive_newsletter+ (получать письма) в таблице +users+. Мы хотим установить значение по умолчанию +false+ для новых пользователей, но для существующих пользователей полагаем, что они выбрали этот вариант, поэтому мы используем модель User, чтобы установить значение +true+ для существующих пользователей.

h4. Использование метода +change+

Rails 3.1 сделал миграции разумнее, предоставив новый метод +change+. Этот метод предпочтителен для написания конструирующих миграций (добавление столбцов или таблиц). Миграция знает, как мигрировать вашу базу данных и обратить ее, когда миграция откатывается, без необходимости писать отдельный метод +down+ method.

<ruby>
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
</ruby>

h4. Миграции это классы

Миграция это субкласс +ActiveRecord::Migration+, который имеет два метода класса: +up+ (выполнение требуемых изменений) и +down+ (их откат).

Active Record предоставляет методы, которые выполняют общие задачи по определению данных способом, независимым от типа базы данных (подробнее об этом будет написано позже):

* +add_column+
* +add_reference+
* +add_index+
* +change_column+
* +change_table+
* +create_table+
* +create_join_table+
* +drop_table+
* +remove_column+
* +remove_index+
* +rename_column+
* +remove_reference+

Если вам нужно выполнить специфичную для вашей базы данных задачу (например, создать "внешний ключ":/rails-database-migrations/active-record-and-referential-integrity как ограничение ссылочной целостности), то функция +execute+ позволит вам запустить произвольный +SQL+. Миграция - всего лишь обычный класс Ruby, так что вы не ограничены этими функциями. Например, после добавления столбца можно написать код, устанавливающий значения этого столбца для существующих записей (если необходимо, используя ваши модели).

В базах данных, поддерживающих транзакции с выражениями, изменяющими схему (такие как PostgreSQL или SQLite3), миграции упаковываются в транзакции. Если база данных не поддерживает это (например, MySQL), то, если миграция проходит неудачно, те части, которые прошли, не откатываются. Вам нужно будет откатить внесенные изменения вручную.

h4. Имена

Миграции хранятся как файлы в директории +db/migrate+, один файл на каждый класс. Имя файла имеет вид +YYYYMMDDHHMMSS_create_products.rb+, это означает, что временная метка UTC идентифицирует миграцию, затем идет знак подчеркивания, затем идет имя миграции, где слова разделены подчеркиваниями. Имя класса миграции содержит буквенную часть названия файла, но уже в формате CamelCase (т.е. слова пишутся слитно, каждое слово начинается с большой буквы). Например, +20080906120000_create_products.rb+ должен определять класс +CreateProducts+, а +20080906120001_add_details_to_products.rb+ должен определять +AddDetailsToProducts+. Если вы вдруг захотите переименовать файл, вы _обязаны_ изменить имя класса внутри, иначе Rails сообщит об отсутствующем классе.

Внутри Rails используются только номера миграций (временные метки) для их идентификации. До Rails 2.1 нумерация миграций начиналась с 1 и увеличивалась каждый раз, когда создавалась новая миграция. Когда работало несколько разработчиков были часты коллизии, когда требовалось перенумеровывать миграции. В Rails 2.1+ этого в большей степени смогли избежать, используя время создания миграции для идентификации. Старую схему нумерации можно вернуть, добавив следующую строку в +config/application.rb+.

<ruby>
config.active_record.timestamped_migrations = false
</ruby>

Комбинация временной метки и записи, какие миграции были выполнены, позволяет Rails регулировать ситуации, которые могут произойти в случае с несколькими разработчиками.

Например, Алиса добавила миграции +20080906120000+ и +20080906123000+, a Боб добавил +20080906124500+ и запустил ее. Алиса закончила свои изменения и отразила их в своих миграциях, а Боб откатывает последние изменения. Когда Боб запускает +rake db:migrate+, Rails знает, что он не запускал две миграции Алисы, таким образом он запускает метод +up+ для каждой миграции.

Конечно, это не замена общения внутри группы. Например, если миграция Алисы убирает таблицу, которую миграция Боба предполагает существующей, возникнут проблемы.

h4. Изменение миграций

Иногда вы можете допустить ошибку, когда пишете миграцию. Если вы уже запустили эту миграцию, то не можете просто отредактировать ее и запустить снова: Rails считает, что эта миграция уже запускалась, и ничего не будет делать, когда вы запустите +rake db:migrate+. Вы должны откатить миграцию (например, командой +rake db:rollback+), отредактировать миграцию и затем запустить +rake db:migrate+ чтобы выполнить скорректированную версию.

В целом, редактирование существующих миграций это не хорошая идея: вы создаете дополнительную работу для себя и своих коллег, и вызываете большую проблему, если существующая версия уже работает в режиме production. Вместо этого вы можете написать новую миграцию, которая выполнит требуемые вами изменения. Редактирование только что созданной миграции, которую еще не передали в систему управлениями версий (то есть которая есть только на вашей машине) относительно безвредно.

h4. Поддерживаемые типы

Active Record поддерживает следующие типы столбцов базы данных:

* +:binary+
* +:boolean+
* +:date+
* +:datetime+
* +:decimal+
* +:float+
* +:integer+
* +:primary_key+
* +:string+
* +:text+
* +:time+
* +:timestamp+

Они отображаются в наиболее подходящем типе базы данных, например, в MySQL тип +:string+ отображается как +VARCHAR(255)+. Вы можете создать столбцы типов, не поддерживаемых Active Record, если будете использовать не секси-синтаксис, такой как

<ruby>
create_table :products do |t|
  t.column :name, 'polygon', :null => false
end
</ruby>

Этот способ, однако, препятствует переходу на другие базы данных.
