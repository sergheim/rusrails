h1. Основы кэширования

Это введение в три типа техники кэширования, предоставленных Rails по умолчанию, без каких-либо посторонних плагинов.

Перед тем, как начать, убедитесь, что +config.action_controller.perform_caching+ установлен +true+, если запущен режим development. Этот флаг обычно устанавливается в соответствующем config/environments/*.rb. По умолчанию кэширование отключено для development и test и включено для production.

<ruby>
config.action_controller.perform_caching = true
</ruby>

h4. Кэширование страницы

Кэширование страницы это механизм Rails, позволяющий запросу на сгенерированную страницу быть полностью обслуженным вебсервером (т.е. Apache или nginx) в принципе, без прохождения через стек Rails. Очевидно, это очень быстро. К сожалению, это не может быть применено к каждой ситуации (например, к страницам, требующим аутентификации), и, так как вебсервер фактически извлекает файл из файловой системы, придется иметь дело с вопросом времени хранения кэша.

Чтобы включить кэширование страниц, следует использовать метод +caches_page+.

<ruby>
class ProductsController < ActionController

  caches_page :index

  def index
    @products = Product.all
  end
end
</ruby>

Предположим, имеется контроллер +ProductsController+ и экшн +index+, отображающий все продукты. Как только кто-то впервые вызовет products/index, Rails создаст файл, названный +index.html+, и затем вебсервер будет видеть этот файл до того, как он передаст следующий запрос к products/index приложению на Rails.

По умолчанию директория кэша страниц устанавливается в Rails.public_path (которая обычно устанавливается как папка +public+), и это можно настроить, изменив конфигурационную настройку +config.action_controller.page_cache_directory+. Изменения умолчания с +public+ поможет избежать конфликт наименований, поскольку вы сможете захотеть разместить другой статичный html в +public+, но изменение этого потребует перенастройку веб сервера, чтобы он знал, откуда обслуживать кэшированные файлы.

Механизм кэширования страниц автоматически добавит расширение +.html+ к запросам страниц, не имеющих расширения, чтобы облегчить веб серверу поиск этих страниц, и это можно настроить, изменив конфигурационную настройку +config.action_controller.page_cache_extension+.

Для того, чтобы эта страница прекращала действие, когда добавляется новый продукт, можно изменить наш пример контроллера следующим образом:

<ruby>
class ProductsController < ActionController

  caches_page :index

  def index
    @products = Product.all
  end

  def create
    expire_page :action => :index
  end

end
</ruby>

Если желаете более сложную схему прекращения, можно использовать уборщики кэша для прекращения кэшированных объектов, если ситуация не меняется. Это раскроем в разделе про Уборщики.

По умолчанию кэширование страницы автоматически сжимает файлы (например, в +products.html.gz+, если пользователь запрашивает +/products+) для уменьшения размера передаваемых данных (веб-серверы обычно настроены на использование умеренного уровня сжатия как компромисс, но, поскольку прекомпиляция происходит лишь раз, уровень сжатия максимальный).

Nginx способен отдавать сжатое содержимое непосредственно с диска с включенным +gzip_static+:

<plain>
location /  {
  gzip_static on; # to serve pre-gzipped version
}
</plain>

Можете отключить сжатие, установив опцию +:gzip+ в false (например, если экшн возвращает изображение):

<ruby>
caches_page :image, :gzip => false
</ruby>

Или установить собственный уровень компрессии (имена уровней берутся из констант +Zlib+):

<ruby>
caches_page :image, :gzip => :best_speed
</ruby>

NOTE: Кэширование страницы игнорирует все параметры. Например, +/products?page=1+ будет записан в файловую систему как +products.html+ без ссылки на параметр +page+. Следовательно, если кто-то позже запросит +/products?page=2+, ему будет возвращена кэшированная первая страница. Это ограничение можно обойти, включив параметры в путь к странице, т.е. +/productions/page/1+.

INFO: Кэширование страниц запускается в последующем (after) фильтре. Следовательно, неверные запросы не будут ложные вхождения кэша, пока вы прерываете их. Обычно эту работу делает перенаправление в некоторых предварительных фильтрах, проверяющие предусловия запроса.

h4. Кэширование экшна

Кэширование страниц нельзя использовать для экшнов, имеющих предварительные фильтры, -- например, для страниц, требующих аутентификации. И тут на помощь приходит кэширование экшна. Кэширование экшна работает как хэширование страницы, за исключением того, что входящий веб запрос затрагивает стек Rails, таким образом, до обслуживания кэша могут быть запущены предварительные (before) фильтры. Это позволит использовать аутентификацию и другие ограничения, и в то же время выводит результат из кэшированной копии.

Чистка кэша происходит так же, как и кэша страниц, за исключением использования +expire_action+ вместо +expire_page+..

Если хотим, чтобы только авторизованные пользователи могли вызывать экшны в +ProductsController+.

<ruby>
class ProductsController < ActionController

  before_filter :authenticate
  caches_action :index

  def index
    @products = Product.all
  end

  def create
    expire_action :action => :index
  end

end
</ruby>

Также можно использовать +:if+ (или +:unless+), чтобы передать Proc, который определяет, когда экшн должен быть кэширован. Также можно использовать +:layout => false+, чтобы кэшировать без макета, таким образом, динамическая информация в макете, такая как имя вошедшего пользователя или предметы на карте, останется незакэшированной. Эта особенность доступна начиная с Rails 2.2.

Можете изменить путь к кэшу экшна по умолчанию, передав опцию +:cache_path+. Это будет передано непосредственно в +ActionCachePath.path_for+. Это удобно для экшнов с несколькими возможными маршрутами, которые должны кэшироваться различно. Если задан блок, он будет вызван текущим экземпляром контроллера.

Наконец, если используете memcached или Ehcache, можете также передать +:expires_in+. Фактически, все параметры, не используемые +caches_action+, посылаются в лежащее в основе хранилище кэша.

INFO: Кэширование страниц запускается в последующем (after) фильтре. Следовательно, неверные запросы не будут ложные вхождения кэша, пока вы прерываете их. Обычно эту работу делает перенаправление в некоторых предварительных фильтрах, проверяющие предусловия запроса.

h4. Кэширование фрагмента

Жить было бы прекрасно, если бы мы могли закэшировать весь контент страницы или экшна и обслуживать с ним всех. К сожалению, динамические веб приложения обычно создают страницы с рядом компонентов, не все из которых имеют сходные характеристики кэширования. Для устранения таких динамически создаваемых страниц, где различные части страниц нуждаются в кэшировании и прекращаются по-разному, Rails предоставляет механизм, названный Кэширование фрагмента.

Кэширование фрагмента позволяет фрагменту логики вьюхи быть обернутым в блок кэша и обслуженным из хранилища кэша для последующего запроса.

Как пример, если хотите показать все заказы, размещенные на веб сайте, в реальном времени и не хотите кэшировать эту часть страницы, но хотите кэшировать часть страницы, отображающей все доступные продукты, можете использовать следующий кусок кода:

<ruby>
<% Order.find_recent.each do |o| %>
  <%= o.buyer.name %> bought <%= o.product.name %>
<% end %>

<% cache do %>
  All available products:
  <% Product.all.each do |p| %>
    <%= link_to p.name, product_url(p) %>
  <% end %>
<% end %>
</ruby>

Блок cache в нашем примере будет привязан к вызвавшему его экшну и записан в тоже место, как кэш экшна, что означает, что если хотите кэшировать несколько фрагментов на экшн, следует предоставить +action_suffix+ в вызове cache:

<ruby>
<% cache(:action => 'recent', :action_suffix => 'all_products') do %>
  All available products:
</ruby>

Можете прекратить кэш, используя метод +expire_fragment+, подобно следующему:

<ruby>
expire_fragment(:controller => 'products', :action => 'recent', :action_suffix => 'all_products')
</ruby>

Если не хотите, чтобы блок cache привязывался к вызвавшему его экшну, можете также использовать глобально настроенные фрагменты, вызвав метод +cache+ с ключом, следующим образом:

<ruby>
<% cache('all_available_products') do %>
  All available products:
<% end %>
</ruby>

Этот фрагмент затем будет доступен во всех экшнах в +ProductsController+ c использованием ключа, и может быть прекращен тем же образом:

<ruby>
expire_fragment('all_available_products')
</ruby>

h4. Уборщики (sweepers)

Уборка кэша это механизм, позволяющий обойти кучу вызовов +expire_{page,action,fragment}+ в коде. Это осуществляется с помощью переноса всей работы, требуемой для прекращения кэшированного содержимого, в класс +ActionController::Caching::Sweeper+. Этот класс является обсервером, просматривающим изменения в объекте Active Record через колбэки, и когда изменение случается, он прекращает кэши, связанные с этим объектом, в фильтрах around или after.

TIP: Уборщики полагаются на использование Active Record и Active Record Observers. Наблюдаемый объект должен быть моделью Active Record.

Продолжая с нашим примером контроллера Product, мы можем переписать его с уборщиком, следующим образом:

<ruby>
class ProductSweeper < ActionController::Caching::Sweeper
  observe Product # This sweeper is going to keep an eye on the Product model

  # Если наш уборщик обнаружит, что Product был создан, вызываем это
  def after_create(product)
    expire_cache_for(product)
  end

  # Если наш уборщик обнаружит, что Product был обновлен, вызываем это
  def after_update(product)
    expire_cache_for(product)
  end

  # Если наш уборщик обнаружит, что Product был удален, вызываем это
  def after_destroy(product)
    expire_cache_for(product)
  end

  private
  def expire_cache_for(product)
    # Прекращает страницу list теперь, когда мы добавили новый продукт
    expire_page(:controller => 'products', :action => 'index')

    # Прекращает фрагмент
    expire_fragment('all_available_products')
  end
end
</ruby>

Можно отметить, что в уборщик передается фактический product, поэтому, если кэшируем экшн edit для каждого product, можно добавить метод прекращения, определяющий страницу, которая должна быть прекращена:

<ruby>
expire_action(:controller => 'products', :action => 'edit', :id => product.id)
</ruby>

Затем добавим уборщик к контроллеру, чтобы сказать ему вызвать уборщик при вызове определенных экшнов. Поэтому, если мы хотим прекращать кэшированное содержимое для экшнов list и edit при вызове экшна create, мы должны сделать следующее:

<ruby>
class ProductsController < ActionController

  before_filter :authenticate
  caches_action :index
  cache_sweeper :product_sweeper

  def index
    @products = Product.all
  end

end
</ruby>

Иногда необходимо устранить неоднозначность, для какого контроллера вы вызывается +expire_action+, так как возможны два одинаково названных контроллера в разных пространствах имен:

<ruby>
class ProductsController < ActionController
  caches_action :index

  def index
    @products = Product.all
  end
end

module Admin
  class ProductsController < ActionController
    cache_sweeper :product_sweeper

    def new
      @product = Product.new
    end

    def create
      @product = Product.create(params[:product])
    end
  end
end

class ProductSweeper < ActionController::Caching::Sweeper
  observe Product

  def after_create(product)
    expire_action(:controller => '/products', :action => 'index')
  end
end
</ruby>

Обратите внимание на использование тут '/products', а вместо 'products'. Если хотите прекратить кэш экшна для +Admin::ProductsController+, вместо этого можно использовать 'admin/products'.

h4. Кэширование SQL

Кэширование запроса это особенность Rails, кэширующая результат выборки по каждому запросу. Если Rails встретит тот же запрос (query) на протяжения текущего запроса (request), он использует кэшированный результат, вместо того, чтобы снова сделать запрос к базе данных.

Например:

<ruby>
class ProductsController < ActionController

  def index
    # Запускаем поисковый запрос
    @products = Product.all

    ...

    # Снова запускаем тот же запрос
    @products = Product.all
  end

end
</ruby>

Второй раз к базе данных обращен тот же запрос, но он фактически не затронет базу данных. Результат, возвращенный первый раз от запроса, сохранится в кэше запроса (в памяти), и во второй раз будет получен из памяти.

Однако, важно отметить, что кэши запросов создаются в начале экшна и уничтожаются в конце этого экшна, и поэтому сохраняются только на протяжении экшна. Если хотите хранить результаты запроса более долгий период, воспользуйтесь низкоуровневым кэшированием Rails.
