h1. Поддержка GET с условием (Conditional GET)

GET с условием это особенность спецификации HTTP, предоставляющая способ вебсерверам сказать браузерам, что отклик на запрос GET не изменился с последнего запроса и может быть спокойно извлечен из кэша браузера.

Это работает с использованием заголовков HTTP_IF_NONE_MATCH и HTTP_IF_MODIFIED_SINCE для передачи туда-обратно уникального идентификатора контента и временной метки, когда содержимое было последний раз изменено. Если браузер делает запрос, в котором идентификатор контента (etag) или временная метка последнего изменения соответствует версии сервера, то серверу всего лишь нужно вернуть пустой отклик со статусом not modified.

Это обязанность сервера (т.е. наша) искать временную метку последнего изменения и заголовок if-none-match, и определять, нужно ли отсылать полный отклик. С поддержкой conditional-get в Rails это очень простая задача:

<ruby>
class ProductsController < ApplicationController

  def show
    @product = Product.find(params[:id])

    # Если запрос устарел в соответствии с заданной временной меткой или значением
    # etag (т.е. нуждается в обработке снова), тогда запускаем этот блок
    if stale?(:last_modified => @product.updated_at.utc, :etag => @product.cache_key)
      respond_to do |wants|
        # ... обычное создание отклика
      end
    end

    # Если запрос свежий (т.е. не изменился), то не нужно ничего делать
    # Рендер по умолчанию проверит это, используя параметры,
    # использованные в предыдущем вызове stale?, и автоматически пошлет
    # :not_modified.  И на этом все.
  end
end
</ruby>

Вместо хэша опций можно просто передать модель, Rails будет использовать методы +updated_at+ и +cache_key+ для настройки +last_modified+ и +etag+:

<ruby>
class ProductsController < ApplicationController
  def show
    @product = Product.find(params[:id])
    respond_with(@product) if stale?(@product)
  end
end
</ruby>

Если отсутствует специальная обработка отклика и используется дефолтный механизм рендеринга (т.е. вы не используете respond_to или вызываете сам render), то можете использовать простой хелпер fresh_when:

<ruby>
class ProductsController < ApplicationController

  # Это автоматически отошлет :not_modified, если запрос свежий,
  # и отрендерит дефолтный шаблон (product.*), если он устарел.

  def show
    @product = Product.find(params[:id])
    fresh_when :last_modified => @product.published_at.utc, :etag => @product
  end
end
</ruby>
