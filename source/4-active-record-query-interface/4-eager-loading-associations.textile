h1. Нетерпеливая загрузка связей

Нетерпеливая загрузка - это механизм загрузки связанных записей объекта, возвращаемого +Model.find+, с использованием как можно меньшего количества запросов.

<strong>Проблема N <plus> 1 запроса</strong>

Рассмотрим следующий код, который находит 10 клиентов и печатает их почтовые индексы:

<ruby>
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
</ruby>

На первый взгляд выглядит хорошо. Но проблема лежит в в общем количестве выполненных запросов. Вышеупомянутый код выполняет 1 (чтобы найти 10 клиентов) <plus> 10 (каждый на одного клиента для загрузки адреса) = итого <strong>11</strong> запросов.

<strong>Решение проблемы N <plus> 1 запроса</strong>

Active Record позволяет усовершенствовано определить все связи, которые должны быть загружены. Это возможно с помощью определения метода +includes+ на вызове +Model.find+. Посредством +includes+, Active Record обеспечивает то, что все определенные связи загружаются с использованием минимально возможного количества запросов.

Пересмотривая вышеупомянутую задачу, мы можем переписать +Client.limit(10)+ для использование нетерпеливой загрузки адресов:

<ruby>
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end
</ruby>

Этот код выполнит всего <strong>2</strong> запроса, вместо <strong>11</strong> запросов в прошлом примере:

<sql>
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
</sql>

h4. Нетерпеливая загрузка нескольких связей

Active Record позволяет нетерпеливо загружать любое количество связей в одном вызове +Model.find+ с использованием массива, хэша, или вложенного хэша массивов/хэшей, с помощью метода +includes+.

h5. Массив нескольких связей

<ruby>
Post.includes(:category, :comments)
</ruby>

Это загрузит все публикации и связанные категорию и комментарии для каждой публикации.

h5. Вложенный хэш связей

<ruby>
Category.includes(:posts => [{:comments => :guest}, :tags]).find(1)
</ruby>

Вышеприведенный код находит категории с id 1 и нетерпеливо загружает все публикации, связанные с найденной категорией. Кроме того, он также нетерпеливо загружает теги и комментарии каждой публикации. Гость, связанный с оставленным комментарием, также будет нетерпеливо загружен.

h4. Определение условий для нетерпеливой загрузки связей

Хотя Active Record и позволяет определить условия для нетерпеливой загрузки связей, как и в +joins+, рекомендуем использовать вместо этого "joins":/active-record-query-interface/joining-tables.

Однако, если вы сделаете так, то сможете использовать +where+ как обычно.

<ruby>
Post.includes(:comments).where("comments.visible" => true)
</ruby>

Это сгенерирует запрос с ограничением +LEFT OUTER JOIN+, в то время как метод +joins+ сгенерировал бы его с использованием функции +INNER JOIN+.

<ruby>
  SELECT "posts"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "posts"
    LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id" WHERE (comments.visible = 1)
</ruby>

Если бы не было условия +where+, то сгенерировался бы обычный набор из двух запросов.

Если, в случае с этим запросом +includes+, не будет ни одного комментария ни для одной публикации, все публикации все равно будут загружены. При использовании +joins+ (INNER JOIN), соединительные условия *должны* соответствовать, иначе ни одной записи не будет возвращено.
