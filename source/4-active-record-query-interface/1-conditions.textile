h1. Условия

Метод +where+ позволяет определить условия для ограничения возвращаемых записей, которые представляют +WHERE+-часть выражения SQL. Условия могут быть заданы как строка, массив или хэш.

h4(#pure-string-conditions). Чисто строковые условия

Если вы хотите добавить условия в свой поиск, можете просто определить их там, подобно +Client.where("orders_count = '2'")+. Это найдет всех клиентов, где значение поля +orders_count+ равно 2.

WARNING: Создание условий в чистой строке подвергает вас риску SQL инъекций. Например, +Client.where("first_name LIKE '%#{params[:first_name]}%'")+ не безопасно. Смотрите следующий раздел для более предпочтительного способа обработки условий с использованием массива.

h4(#array-conditions). Условия с использованием массива

Что если количество может изменяться, скажем, как аргумент извне, возможно даже от пользователя? Поиск тогда принимает такую форму:

<ruby>
Client.where("orders_count = ?", params[:orders])
</ruby>

Active Record проходит через первый элемент в переданных условиях, подставляя остальные элементы вместо знаков вопроса +(?)+ в первом элементе.

Если хотите определить несколько условий:

<ruby>
Client.where("orders_count = ? AND locked = ?", params[:orders], false)
</ruby>

В этом примере первый знак вопроса будет заменен на значение в +params[:orders]+ и второй будет заменен SQL аналогом +false+, который зависит от адаптера.

Этот код значительно предпочтительнее:

<ruby>
Client.where("orders_count = ?", params[:orders])
</ruby>

чем такой код:

<ruby>
Client.where("orders_count = #{params[:orders]}")
</ruby>

по причине безопасности аргумента. Помещение переменной прямо в строку условий передает переменную в базу данных _как есть_. Это означает, что неэкранированная переменная, переданная пользователем, может иметь злой умысел. Если так сделать, вы подвергаете базу данных риску, так как если пользователь обнаружит, что он может использовать вашу базу данных, то он сможет сделать с ней что угодно. Никогда не помещайте аргументы прямо в строку условий!

TIP: Подробнее об опасности SQL инъекций можно узнать из "Руководства Ruby On Rails по безопасности":/ruby-on-rails-security-guide.

h5. Символы-заполнители в условиях

Подобно тому, как +(?)+ заменяют параметры, можно использовать хэш ключей/параметров в условиях с использованием массива:

<ruby>
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {:start_date => params[:start_date], :end_date => params[:end_date]})
</ruby>

Читаемость улучшится, в случае если вы используете большое количество переменных в условиях.

h4(#hash-conditions). Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, равными полям, к которым применяются условия, и с значениями, указывающим каким образом вы хотите применить к ним условия:

NOTE: Хэшем можно передать условия проверки только равенства, интервала и подмножества.

h5. Условия равенства

<ruby>
Client.where(:locked => true)
</ruby>

Имя поля также может быть строкой, а не символом:

<ruby>
Client.where('locked' => true)
</ruby>

NOTE: Значения не могут быть символами. Например, нельзя сделать +Client.where(:status => :active)+.

h5(#hash-range_conditions). Интервальные условия

<ruby>
Client.where(:created_at => (Time.now.midnight - 1.day)..Time.now.midnight)
</ruby>

Это найдет всех клиентов, созданных вчера, с использованием SQL выражения +BETWEEN+:

<sql>
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
</sql>

Это была демонстрация более короткого синтаксиса для примеров в "Условия с использованием массива":#array-conditions

h5. Условия подмножества

Если хотите найти записи, используя выражение +IN+, можете передать массив в хэш условия:

<ruby>
Client.where(:orders_count => [1,3,5])
</ruby>

Этот код создаст подобный SQL:

<sql>
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
</sql>
