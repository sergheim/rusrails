h1. В production

В среде production Rails использует схему меток, "описанную ранее":/asset-pipeline/what-is-the-asset-pipeline. По умолчанию Rails полагает, что ресурсы прекомпилированы и будут отданы как статичные ресурсы вашим веб-сервером.

В течение фазы прекомпиляции из содержимого компилированных файлов создается MD5 и вставляется в имена файлов, когда они записываются на диск. Эти имена меток используются хелперами Rails вместо имени манифеста.

Например, это:

<erb>
<%= javascript_include_tag "application" %>
<%= stylesheet_link_tag "application" %>
</erb>

создаст что-то наподобие этого:

<html>
<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>
<link href="/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css" media="screen" rel="stylesheet" />
</html>

Режим меток контролируется установкой настройки +config.assets.digest+ в Rails (которая по умолчанию +true+ для production, +false+ для всего остального).

NOTE: В нормальных обстоятельствах опция по умолчанию не должна изменяться. Если нет дайджеста в именах файлов и установлены заголовки с вечным кэшированием, удаленные клиенты никогда не узнают, когда перезапросить файлы при изменении ихсодержимого.

h4. Прекомпиляция ресурсов

В Rails имеется встроенная задача rake для компиляции на диск манифестов ресурсов и других файлов в файлопроводе.

Скомпилированные ресурсы записываются в адрес, указанный в +config.assets.prefix+. По умолчанию это директория +public/assets+.

Эту задачу можно вызвать на сервере во время деплоймента, чтобы создать скомпилированные версии ресурсов непосредствено на сервере. Смотрите следующий размер, чтобы узнать о том, как скомпилировать локально.

Задача rake такая:

<plain>
bundle exec rake assets:precompile
</plain>

Для быстрой прекомпиляции ресурсов можно частично загрузить свое приложение, установив +config.assets.initialize_on_precompile+ в false в +config/application.rb+, хотя в этом случае шаблоны не смогут видеть объекты или методы приложения. *Heroku требует, чтобы было false.*

WARNING: Если установить +config.assets.initialize_on_precompile+ в false, до деплоя протестируйте +rake assets:precompile+ локально. Это может вызвать баги, когда ваши ресурсы ссылаются на объекты или методы приложения, так как они все в режиме development они все еще находятся в области видимости независимо от значения этого флажка. Изменение этого флажка также влияет на engine. Engine также может определять ресурсы для прекомпиляции. Пока окружение полностью не загружено, engine (или другие гемы) не будут загружены, что может привести к отсутствущим ресурсам.

Capistrano (v2.8.0 и выше) включает рецепт для управления этим при деплое. Добавьте следующую строку в +Capfile+:

<erb>
load 'deploy/assets'
</erb>

Это свяжет папку, указанную в +config.assets.prefix+ с +shared/assets+. Если вы уже используете эту общую папку, вам следует написать собственную задачу для деплоя.

Важно то, что эта папка является общей между деплоями, так что удаленно кэшированные страницы, ссылающиеся на старые скомпилированные ресурсы, все еще будут работать, пока не истечет срок кэширования.

NOTE. Если вы прекомпилируете ресурсы локально, на сервере можно использовать +bundle install --without assets+, чтобы избежать установки гемов для ресурсов (гемов в группе assets в Gemfile).

По умолчанию компилирующиеся файлы включают +application.js+, +application.css+ и все не-JS/CSS файлы (это автоматически включает все ресурсы изображений):

<ruby>
[ Proc.new{ |path| !%w(.js .css).include?(File.extname(path)) }, /application.(css|js)$/ ]
</ruby>

NOTE. Условие отбора (и другие части прекомпиляционного массива; смотрите выше) применяется к итоговым скомпилированным именам файлов. Это означает, что все, что компилируется в JS/CSS, исключается, так же, как и файлы с чистым JS/CSS; например, файлы +.coffee+ и +.scss+ *не* включаются автоматически, так как они компилируются в JS/CSS.

Ели у вас имеются для включения другие манифесты или отдельные таблицы стилей или файлы JavaScript, их можно добавить в массив +precompile+:

<erb>
config.assets.precompile += ['admin.js', 'admin.css', 'swfObject.js']
</erb>

NOTE. Всегда определяйте ожидаемое имя скомпилированного файла, оканчивающееся на js или css, даже если хотите добавить в массив прекомпиляции файлы Sass или CoffeeScript.

Задача rake также создает +manifest.yml+, который содержит список всех ваших ресурсов и их соответствующие метки. Это используется методами хелпера Rails, чтобы избежать направления запроса в Sprockets. Обычный файл манифеста выглядит так:

<plain>
---
rails.png: rails-bd9ad5a560b5a3a7be0808c5cd76a798.png
jquery-ui.min.js: jquery-ui-7e33882a28fc84ad0e0e47e46cbf901c.min.js
jquery.min.js: jquery-8a50feed8d29566738ad005e19fe1c2d.min.js
application.js: application-3fdab497b8fb70d20cfc5495239dfc29.js
application.css: application-8af74128f904600e41a6e39241464e03.css
</plain>

Размещение манифеста по умолчанию -- корень папки, определенной в +config.assets.prefix+ (по умолчанию '/assets').

Это может быть изменено с помощью опции +config.assets.manifest+. Требуется полностью определенный путь:

<erb>
config.assets.manifest = '/path/to/some/other/location'
</erb>

NOTE: Если в production отсутствуют прекомпилированные файлы, вы получите исключение <tt>Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError</tt>, указывающее имя отсутствующего файла(-ов).

h5. Вечный заголовок Expires

Прекомпилированные ресурсы существуют в файловой системе и отдаются непосредственно веб-сервером. По умолчанию у них нет заголовков вечного кэширования, таким образом, чтобы получить преимущество от меток, необходимо обновить конфигурацию вашего сервера.

Для Apache:

<plain>
# Директивы Expires* требуют, чтобы модуль Apache +mod_expires+ был включен.
<LocationMatch "^/assets/.*$">
  # Не рекомендуется использование ETag, когда присутствует Last-Modified
  Header unset ETag
  FileETag None
  # RFC предписывает кэшировать только на 1 год
  ExpiresActive On
  ExpiresDefault "access plus 1 year"
</LocationMatch>
</plain>

Для nginx:

<plain>
location ~ ^/assets/ {
  expires 1y;
  add_header Cache-Control public;

  add_header ETag "";
  break;
}
</plain>

h5. Сжатие GZip

При прекомпиляции файлов Sprockets также создает "gzipped":http://en.wikipedia.org/wiki/Gzip (.gz) версию ваших ресурсов. Web серверы обычно настроены использовать умеренный уровень сжатия как компромисс, но, поскольку прекомпиляция случается единожды, Sprockets использует максимальный уровень компрессии, что уменьшает размер передачи данных до минимума. С другой стороны, веб-серверы могут быть настроены отдавать сжатый контент непосредственно с диска, не сжимая сами несжатые файлы.

Nginx может это делать автоматически, если включить +gzip_static+:

<plain>
location ~ ^/(assets)/  {
  root /path/to/public;
  gzip_static on; # to serve pre-gzipped version
  expires max;
  add_header Cache-Control public;
}
</plain>

Эта директива доступна, если модуль, предоставляющий эту возможность, был скомпилирован вместе с веб-сервером. Пакеты Ubuntu, даже +nginx-light+, имеют этот модель скомпилированым. Иначе необходимо выполнить ручную компиляцию:

<plain>
./configure --with-http_gzip_static_module
</plain>

Если компилируете nginx вместе с Phusion Passenger, необходимо передать эту опцию, когда будет предложено.

Надежная конфигурация для Apache возможна, но сложна, гуглите, пожалуйста.

h4. Локальная прекомпиляция

Имеется несколько причин того, что может возникнуть желание компилировать ресурсы локально. Вот некоторые из них:

* У вас нет права записи в файловую систему production.
* Вы размещаетесь более чем на одном сервере и хотите избежать дублирования работы.
* Вы часто производите деплои, не включающие изменения ресурсов.

Локальная компиляция позволяет зафиксировать скомпилироанные файлы в управлении версиями и деплоить, как обычно.

Однако есть две оговорки:

* Вы не должны запускать задачу Capistrano, которая компилирует ресурсы.
* Вы должны изменить две следующие конфигурационные настройки приложения.

В <tt>config/environments/development.rb</tt> поместите следующую строчку:

<erb>
config.assets.prefix = "/dev-assets"
</erb>

И также необходимо в application.rb:

<erb>
config.assets.initialize_on_precompile = false
</erb>

Изменение +prefix+ позволяет Rails использовать другой URL для обслуживания ресурсов в режиме development и передавать все запросы в Sprockets. Префикс остался установленным +/assets+ в режиме production. Без этого изменения приложение будет обслуживаться прекомпилированными ресурсами из +public/assets+ в development, и вы не увидите какие-либо локальные изменения, пока снова не скомпилируете ресурсы.

Изменение +initialize_on_precompile+ сообщает таску прекомпиляции запускаться без вызова Rails. Это так, потому что таск прекомпиляции запускается по умолчанию в режиме production и попытается соединиться с базой данных, определенной для production. Отметьте, пожалуйста, что в файлах файлопровода не должно быть кода, основанного на ресурсах Rails (таких как база данных) при локальной компиляции с этой опцией.

Также необходимо убедиться, что в вашей development системе доступны используемые компрессоры или минифайеры.

На практике это позволит прекомпилировать локально, держать эти файлы в рабочей ветке и при необходимости фиксировать в системе контроля версий. Режим development будет работать так, как от от него ожидается.

h4. Компиляция в реальном времени

В некоторых обстоятельствах вам, возможно, захочется использовать компиляцию в реальном времени. В этом режиме все запросы для ресурсов в файлопроводе обрабатываются непосредственно Sprockets.

Чтобы включить эту опцию, установите:

<erb>
config.assets.compile = true
</erb>

При первом запросе ресурсы компилируются и кэшируются так, как описывалось в разделе про "development":/asset-pipeline/in-development, и имена манифеста, использованного в хелперах, изменяется путем ключения хеша MD5.

Sprockets также устанавливает HTTP заголовок +Cache-Control+ как +max-age=31536000+. Это сигнализирует всем кэшам между вашим сервером и браузером клиента, что это содержимое (отданный файл) может быть закэшировано на 1 год. В результате уменьшается количество запросов для этого ресурса на ваш сервер; есть хороший шанс, что ресурс будет в локальном кэше браузера или в каком-либо промежуточном кэше.

Этот режим использует больше памяти, имеет худшее быстродействие, чем по умолчанию, и не рекомендуется.

Если приложение размещается в системе без существующего JavaScript runtimes, возможно захочетсв добавить это в Gemfile:

<plain>
group :production do
  gem 'therubyracer'
end
</plain>
