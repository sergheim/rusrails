h1. Обзор валидаций

Прежде чем погрузиться в подробности о валидациях в Rails, нужно немного понять, как валидации вписываются в общую картину.

h4. Зачем использовать валидации?

Валидации используются, чтобы быть уверенными, что только валидные данные сохраняются в вашу базу данных. Например, для вашего приложения может быть важно, что каждый пользователь предоставил валидный электронный и почтовый адреса.

Есть несколько способов валидации данных, прежде чем они будут сохранены в вашу базу данных, включая ограничения, встроенные в базу данных, валидации на клиентской части, валидации на уровне контроллера и валидации на уровне модели:

* Ограничения базы данных и/или хранимые процедуры делают механизмы валидации зависимыми от базы данных, что делает тестирование и поддержку более трудными. Однако, если ваша база данных используется другими приложениями, валидация на уровне базы данных может безопасно обрабатывать некоторые вещи (такие как уникальность в нагруженных таблицах), которые затруднительно выполнять по другому.
* Валидации на клиентской части могут быть очень полезны, но в целом ненадежны, если используются в одиночку. Если они используют JavaScript, они могут быть пропущены, если JavaScript отключен в клиентском браузере. Однако, если этот способ комбинировать с другими, валидации на клиентской части могут быть удобным способам предоставить пользователям немедленную обратную связь при использовании вашего сайта.
* Валидации на уровне контроллера заманчиво делать, но это часто приводит к громоздкости и трудности тестирования и поддержки. Во всех случаях, когда это возможно, "держите свои контроллеры 'тощими'":http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model, тогда с вашим приложением будет приятно работать в долгосрочной перспективе.
* Валидации на уровне модели - лучший способ быть уверенным, что только валидные данные сохраняются в вашу базу данных. Они безразличны к базе данных, не могут быть обойдены конечным пользователем и удобны для тестирования и поддержки. Rails делает их простыми в использовании, предоставляет встроенные хелперы для общих нужд и позволяет вам создавать свои собственные валидационные методы.

h4. Когда происходит валидация?

Есть два типа объектов Active Record: те, которые соответствуют строке в вашей базе данных, и те, которые нет. Когда создаете новый объект, например, используя метод +new+, этот объект еще не привязан к базе данных. Как только вы вызовете +save+. этот объект будет сохранен в подходящую таблицу базы данных. Active Record использует метод экземпляра +new_record?+ для определения, есть ли уже объект в базе данных или нет. Рассмотрим следующий простой класс Active Record:

<ruby>
class Person < ActiveRecord::Base
end
</ruby>

Можно увидеть, как он работает, взглянув на результат +rails console+:

<ruby>
>> p = Person.new(:name => "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
</ruby>

Создание и сохранение новой записи посылает операцию SQL +INSERT+ базе данных. Обновление существующей записи вместо этого посылает операцию SQL +UPDATE+. Валидации обычно запускаются до того, как эти команды посылаются базе данных. Если любая из валидаций проваливается, объект помечается как недействительный и Active Record не выполняет операцию +INSERT+ или +UPDATE+. Это помогает избежать хранения невалидного объекта в базе данных. Можно выбирать запуск специфичных валидаций, когда объект создается, сохраняется или обновляется.

CAUTION: Есть разные методы изменения состояния объекта в базе данных. Некоторые методы вызывают валидации, некоторые нет. Это означает, что возможно сохранить в базу данных объект с недействительным статусом, если вы будете не внимательны.

Следующие методы вызывают валидацию, и сохраняют объект в базу данных только если он валиден:

* +create+
* +create!+
* +save+
* +save!+
* +update+
* +update_attributes+
* +update_attributes!+

Версии с восклицательным знаком (т.е. +save!+) вызывают исключение, если запись недействительна. Невосклицательные версии не вызывают: +save+ и +update_attributes+ возвращают +false+, +create+ и +update+ возвращают объекты.

h4. Пропуск валидаций

Следующие методы пропускают валидации, и сохраняют объект в базу данных, независимо от его валидности. Их нужно использовать осторожно.

* +decrement!+
* +decrement_counter+
* +increment!+
* +increment_counter+
* +toggle!+
* +touch+
* +update_all+
* +update_attribute+
* +update_column+
* +update_columns+
* +update_counters+

Заметьте, что +save+ также имеет способность пропустить валидации, если как передать +:validate => false+ как аргумент. Этот способ нужно использовать осторожно.

* +save(:validate => false)+

h4. +valid?+ или +invalid?+

Чтобы определить, валиден объект или нет, Rails использует метод +valid?+. Вы также можете его использовать для себя. +valid?+ вызывает ваши валидации и возвращает true, если ни одной ошибки не было найдено у объекта, иначе false.

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true
end

Person.create(:name => "John Doe").valid? # => true
Person.create(:name => nil).valid? # => false
</ruby>

После того, как Active Record выполнит валидации, все найденные ошибки будут доступны в методе экземпляра +errors+, возвращающем коллекцию ошибок. По определению объект валиден, если эта коллекция будет пуста после запуска валидаций.

Заметьте, что объект, созданный с помощью +new+ не сообщает об ошибках, даже если технически невалиден, поскольку валидации не запускаются при использовании +new+.

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true
end

>> p = Person.new
=> #<Person id: nil, name: nil>
>> p.errors
=> {}

>> p.valid?
=> false
>> p.errors
=> {:name=>["can't be blank"]}

>> p = Person.create
=> #<Person id: nil, name: nil>
>> p.errors
=> {:name=>["can't be blank"]}

>> p.save
=> false

>> p.save!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

>> Person.create!
=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
</ruby>

+invalid?+ это просто антипод +valid?+. +invalid?+ запускает ваши валидации, возвращая true, если для объекта были добавлены ошибки, и false в противном случае.

h4. +errors[]+

Чтобы проверить, является или нет конкретный атрибут объекта валидным, можно использовать +errors[:attribute]+, который возвращает массив со всеми ошибками атрибута, когда нет ошибок по определенному атрибуту, возвращается пустой массив.

Этот метод полезен только _после того_, как валидации были запущены, так как он всего лишь исследует коллекцию errors, но сам не вызывает валидации. Он отличается от метода +ActiveRecord::Base#invalid?+, описанного выше, тем, что не проверяет валидность объекта в целом. Он всего лишь проверяет, какие ошибки были найдены для отдельного атрибута объекта.

<ruby>
class Person < ActiveRecord::Base
  validates :name, :presence => true
end

>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => true
</ruby>

Мы рассмотрим ошибки валидации подробнее в разделе "Работаем с ошибками валидации":/active-record-validations-and-callbacks/working-with-validation-errors. А сейчас обратимся к встроенным валидационным хелперам, предоставленным Rails по умолчанию.
