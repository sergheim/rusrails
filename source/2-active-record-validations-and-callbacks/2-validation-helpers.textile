h1. Валидационные хелперы

Active Record предлагает множество предопределенных валидационных хелперов, которые Вы можете использовать прямо внутри Ваших определений класса. Эти хелперы предоставляют общие правила валидации. Каждый раз, когда валидация проваливается, сообщение об ошибке добавляется в коллекцию +errors+ объекта, и это сообщение связывается с аттрибутом, который подлежал валидации.

Каждый хелпер принимает произвольное количество имен аттрибутов, поэтому в одной строке кода можно добавить валидации одинакового вида для нескольких аттрибутов.

Они все принимают опции +:on+ и +:message+, которые определяют, когда валидация должна быть запущена, и какое сообщение должно быть добавлено в коллекцию +errors+, если она провалится. Опция +:on+ принимает одно из значений +:save+ (по умолчанию), +:create+ или +:update+. Для каждого валидационного хелпера есть свое сообщение об ошибке по умолчанию. Эти сообщения используются, если не определена опция +:message+. Давайте рассмотрим каждый из доступных хелперов.

h4. +acceptance+

Проверяет, что чекбокс в пользовательском интерфейсе был нажат, когда форма была подтверждена. Обычно используется, когда пользователю нужно согласиться с условиями использования Вашего приложения, подтвердить прочтение некоторого текста или выполнить любое подобное действие. Валидация очень специфична для веб приложений, и ее принятие не нужно записывать куда-либо в базу данных (если у Вас нет поля для него, хелпер всего лишь создаст виртуальный аттрибут).

<ruby>
class Person < ActiveRecord::Base
  validates :terms_of_service, :acceptance => true
end
</ruby>

Для этого хелпера сообщение об ошибке по умолчанию следующее "_must be accepted_".

Он может получать опцию +:accept+, которая определяет значение, которое должно считаться принятым. По умолчанию это "1", но его можно изменить.

<ruby>
class Person < ActiveRecord::Base
  validates :terms_of_service, :acceptance => { :accept => 'yes' }
end
</ruby>

h4. +validates_associated+

Этот хелпер можно использовать, когда у вашей модели есть связи с другими моделями, и их также нужно проверить на валидность. Когда вы пытаетесь сохранить свой объект, будет вызван метод +valid?+ для каждого из связанных объектов.

<ruby>
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
</ruby>

Эта валидация работает со всеми типами связей.

CAUTION: Не используйте +validates_associated+ на обоих концах ваших связей, они будут вызывать друг друга в бесконечном цикле.

Для +validates_associated+ сообщение об ошибке по умолчанию следующее "_is invalid_". Заметьте, что каждый связанный объект имеет свою собственную коллекцию +errors+; ошибки не добавляются к вызывающей модели.

h4. +confirmation+

Этот хелпер можно использовать, если у вас есть два текстовых поля, из которых нужно получить полностью идентичное содержание. Например, вы хотите подтверждение адреса электронной почты или пароля. Эта валидация создает виртуальный атрибут, имя которого равно имени подтверждаемого поля с добавлением "_confirmation".

<ruby>
class Person < ActiveRecord::Base
  validates :email, :confirmation => true
end
</ruby>

В вашем шаблоне вьюхи нужно использовать что-то вроде этого

<erb>
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
</erb>

Эта проверка выполняется, только если +email_confirmation+ не равно +nil+. Чтобы требовать подтверждение, нужно добавить еще проверку на существование проверяемого аттрибута (мы рассмотрим +presence+ чуть позже):

<ruby>
class Person < ActiveRecord::Base
  validates :email, :confirmation => true
  validates :email_confirmation, :presence => true
end
</ruby>

По умолчанию сообщение об ошибке для этого хелпера такое "_doesn't match confirmation_".

h4. +exclusion+

Этот хелпер проводит валидацию того, что значения аттрибутов не включены в указанный набор. Фактически, этот набор может быть любым перечисляемым объектом.

<ruby>
class Account < ActiveRecord::Base
  validates :subdomain, :exclusion => { :in => %w(www us ca jp),
    :message => "Subdomain %{value} is reserved." }
end
</ruby>

Хелпер +exclusion+ имеет опцию +:in+, которая получает набор значений, которые не должны приниматься проверяемыми аттрибутами. Опция +:in+ имеет псевдоним +:within+, который используется для тех же целей. Этот пример использует опцию +:message+, чтобы показать вам, как можно включать значение аттрибута.

Значение сообщения об ошибке по умолчанию "_is reserved_".

h4. +format+

Этот хелпер проводит валидацию значений аттрибутов, тестируя их на соответствие указанному регулярному выражению, которое определяется с помощью опции +:with+.

<ruby>
class Product < ActiveRecord::Base
  validates :legacy_code, :format => { :with => /\A[a-zA-Z]+\z/,
    :message => "Only letters allowed" }
end
</ruby>

Значение сообщения об ошибке по умолчанию "_is invalid_".

h4. +inclusion+

Этот хелпер проводит валидацию значений аттрибутов на включение в указанный набор. Фактически этот набор может быть любым перечисляемым объектом.

<ruby>
class Coffee < ActiveRecord::Base
  validates :size, :inclusion => { :in => %w(small medium large),
    :message => "%{value} is not a valid size" }
end
</ruby>

Хелпер +inclusion+ имеет опцию +:in+, которая получает набор значений, которые должны быть приняты. Опция +:in+ имеет псевдоним +:within+, который используется для тех же целей. Предыдущий пример использует опцию +:message+, чтобы показать вам, как можно включать значение аттрибута.

Значение сообщения об ошибке по умолчанию для этого хелпера такое "_is not included in the list_".

h4. +length+

Этот хелпер проводит валидацию длины значений аттрибутов. Он предлагает ряд опций, с помощью которых вы можете определить ограничения по длине разными способами:

<ruby>
class Person < ActiveRecord::Base
  validates :name, :length => { :minimum => 2 }
  validates :bio, :length => { :maximum => 500 }
  validates :password, :length => { :in => 6..20 }
  validates :registration_number, :length => { :is => 6 }
end
</ruby>

Возможные опции ограничения длины такие:

* +:minimum+ - аттрибут не может быть меньше определенной длины.
* +:maximum+ - аттрибут не может быть больше определенной длины.
* +:in+ (или +:within+) - длина аттрибута должна находиться в указанном интервале. Значение этой опции должно быть интервалом.
* +:is+ - длина аттрибута должна быть равной указанному значению.

Значение сообщения об ошибке по умолчанию зависит от типа выполняемой валидации длины. Можно переопределить эти сообщения, используя опции +:wrong_length+, +:too_long+ и +:too_short+, и +%{count}+ как место для вставки числа, соответствующего длине используемого ограничения. Можете использовать опцию +:message+ для определения сообщения об ошибке.

<ruby>
class Person < ActiveRecord::Base
  validates :bio, :length => { :maximum => 1000,
    :too_long => "%{count} characters is the maximum allowed" }
end
</ruby>

По умолчанию этот хелпер считает символы, но вы можете разбить значение иным способом используя опцию +:tokenizer+:

<ruby>
class Essay < ActiveRecord::Base
  validates :content, :length => {
    :minimum   => 300,
    :maximum   => 400,
    :tokenizer => lambda { |str| str.scan(/\w+/) },
    :too_short => "must have at least %{count} words",
    :too_long  => "must have at most %{count} words"
  }
end
</ruby>

Отметьте, что сообщения об ошибке по умолчанию во множественном числе (т.е., "is too short (minimum is %{count} characters)"). По этой причине, когда +:minimum+ равно 1, следует предоставить собственное сообщение или использовать вместо него +validates_presence_of+. Когда +:in+ или +:within+ имеют как нижнюю границу 1, следует или предоставить собственное сообщение, или вызвать +presence+ перед +length+.

Хелпер +size+ это псевдоним для +length+.

h4. +numericality+

Этот хелпер проводит валидацию того, что ваши аттрибуты имеют только числовые значения. По умолчанию, этому будет соответствовать возможный знак первым символом, и следующее за ним целочисленное или с плавающей запятой число. Чтобы определить, что допустимы только целочисленные значения, установите +:only_integer+ в true.

Если установить +:only_integer+ в +true+, тогда будет использоваться регулярное выражение

<ruby>
/\A[<plus>-]?\d<plus>\Z/
</ruby>

для проведения валидации значения атрибута. В противном случае, он будет пытаться конвертировать значение в число, используя +Float+.

WARNING. Отметьте, что вышеописанное регулярное выражение позволяет завершающий символ перевода строки

<ruby>
class Player < ActiveRecord::Base
  validates :points, :numericality => true
  validates :games_played, :numericality => { :only_integer => true }
end
</ruby>

Кроме +:only_integer+, хелпер +validates_numericality_of+ также принимает следующие опции для добавления ограничений к приемлемым значениям:

* +:greater_than+ - определяет, что значение должно быть больше, чем значение опции. По умолчанию сообщение об ошибке для этой опции такое "_must be greater than %{count}_".
* +:greater_than_or_equal_to+ - определяет, что значение должно быть больше или равно значению опции. По умолчанию сообщение об ошибке для этой опции такое "_must be greater than or equal to %{count}_".
* +:equal_to+ - определяет, что значение должно быть равно значению опции. По умолчанию сообщение об ошибке для этой опции такое "_must be equal to %{count}_".
* +:less_than+ - определяет, что значение должно быть меньше, чем значение опции. По умолчанию сообщение об ошибке для этой опции такое "_must be less than %{count}_".
* +:less_than_or_equal_to+ - определяет, что значение должно быть меньше или равно значению опции. По умолчанию сообщение об ошибке для этой опции такое "_must be less than or equal to %{count}_".
* +:odd+ - определяет, что значение должно быть нечетным, если установлено true. По умолчанию сообщение об ошибке для этой опции такое "_must be odd_".
* +:even+ - определяет, что значение должно быть четным, если установлено true. По умолчанию сообщение об ошибке для этой опции такое "_must be even_".

По умолчанию сообщение об ошибке "_is not a number_".

h4. +presence+

Этот хелпер проводит валидацию того, что определенные аттрибуты не пустые. Он использует метод +blank?+ для проверки того, является ли значение или +nil+, или пустой строкой (это строка, которая или пуста, или содержит пробелы).

<ruby>
class Person < ActiveRecord::Base
  validates :name, :login, :email, :presence => true
end
</ruby>

Если хотите быть уверенным, что связь существует, нужно проверить, существует ли внешний ключ, используемый для связи, но не сам связанный объект.

<ruby>
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order_id, :presence => true
end
</ruby>

При проведении волидации существования объекта, связанного отношением +has_one+ или +has_many+, будет проверено, что объект ни +blank?+, ни +marked_for_destruction?+.

Так как +false.blank?+ это true, если хотите провести валидацию существования булева поля, нужно использовать +validates :field_name, :inclusion => { :in => [true, false] }+.

По умолчанию сообщение об ошибке "_can't be empty_".

h4. +uniqueness+

Этот хелпер проводит валидацию того, что значение атрибута уникально, перед тем, как объект будет сохранен. Он не создает условие уникальности в базе данных, следовательно, может произойти так, что два разных подключения к базе данных создадут две записи с одинаковым значением для столбца, который вы подразумеваете уникальным. Чтобы этого избежать, нужно создать индекс unique в вашей базе данных.

<ruby>
class Account < ActiveRecord::Base
  validates :email, :uniqueness => true
end
</ruby>

Валидация производится путем SQL запроса в таблицу модели, поиска существующей записи с тем же значением аттрибута.

Имеется опция +:scope+, которую можно использовать для определения других аттрибутов, используемых для ограничения проверки уникальности:

<ruby>
class Holiday < ActiveRecord::Base
  validates :name, :uniqueness => { :scope => :year,
    :message => "should happen once per year" }
end
</ruby>

Также имеется опция +:case_sensitive+, которой можно определить, будет ли ограничение уникальности чувствительно к регистру или нет. Опция по умолчанию равна true.

<ruby>
class Person < ActiveRecord::Base
  validates :name, :uniqueness => { :case_sensitive => false }
end
</ruby>

WARNING. Отметьте, что некоторые базы данных настроены на выполнение чувствительного к регистру поиска в любом случае.

По умолчанию сообщение об ошибке "_has already been taken_".

h4. +validates_with+

Этот хелпер передает запись в отдельный класс для валидации.

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end

class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

NOTE: Ошибки, добавляемые в +record.errors[:base]+ относятся к состоянию записи в целом, а не к определенному аттрибуту.

Хелпер +validates_with+ принимает класс или список классов для использования в валидации. Для +validates_with+ нет сообщения об ошибке по умолчанию. Следует вручную добавлять ошибки в коллекцию errors записи в классе валидатора.

Для применения метода validate, необходимо иметь определенным параметр +record+, который является записью, проходящей валидацию.

Подобно всем другим валидациям, +validates_with+ принимает опции +:if+, +:unless+ и +:on+. Если передадите любые другие опции, они будут пересланы в класс валидатора как +options+:

<ruby>
class Person < ActiveRecord::Base
  validates_with GoodnessValidator, :fields => [:first_name, :last_name]
end

class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
</ruby>

h4. +validates_each+

Этот хелпер помогает провести валидацию атрибутов с помощью блока кода. Он не имеет предопределенной валидационной функции. Вы должны создать ее, используя блок, и каждый атрибут, указанный в +validates_each+, будет протестирован в нем. В следующем примере нам не нужны имена и фамилии, начинающиеся с маленькой буквы.

<ruby>
class Person < ActiveRecord::Base
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end
</ruby>

Блок получает запись, имя атрибута и значение атрибута. Вы можете делать что угодно для проверки валидности данных внутри блока. Если валидация проваливается, следует добавить сообщение об ошибке в модель, которое делает ее невалидной.
