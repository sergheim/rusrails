h1. Функциональные тесты для ваших контроллеров

В Rails тестирование различных экшнов одного контроллера называется написанием функциональных тестов для этого контроллера. Контроллеры обрабатывают входящие веб запросы к вашему приложению и в конечном итоге откликаются отрендеренной вьюхой.

h4. Что включать в функциональные тесты

Следует протестировать такие вещи, как:

* был ли веб запрос успешным?
* был ли пользователь перенаправлен на правильную страницу?
* был ли пользователь успешно аутентифицирован?
* был ли правильный объект сохранен в шаблон отклика?
* было ли подходящее сообщение отражено для пользователя во вьюхе

Теперь, когда мы использовали Rails scaffold generator для нашего ресурса +Post+, он также создал код контроллера и функциональные тесты. Можете посмотреть файл <tt>posts_controller_test.rb</tt> в директории +test/functional+.

Давайте пробежимся про одному такому тесту, +test_should_get_index+ из файла +posts_controller_test.rb+.

<ruby>
test "should get index" do
  get :index
  assert_response :success
  assert_not_nil assigns(:posts)
end
</ruby>

В тесте +test_should_get_index+, Rails имитирует запрос к экшну index, убеждается, что запрос был успешным, а также обеспечивает, что назначается валидная переменная экземпляра +posts+.

Метод +get+ стартует веб запрос и заполняет результаты в ответ. Он принимает 4 аргумента:

* Экшн контроллера, к которомы обращаетесь. Он может быть в форме строки или символа.
* Необязательный хэш параметров запроса для передачи в экшн (эквивалент параметров строки запроса или переменных post).
* Необязательный хэш переменных сессии для передачи вместе с запросом.
* Необязательный хэш значений flash.

Пример: Вызов экшна +:show+, передача +id+, равного 12, как +params+, и установка +user_id+ как 5 в сессии:

<ruby>
get(:show, {'id' => "12"}, {'user_id' => 5})
</ruby>

Другой пример: Вызов экшна +:view+, передача +id+, равного 12, как +params+, в этот раз без сессии, но с сообщением flash.

<ruby>
get(:view, {'id' => '12'}, nil, {'message' => 'booya!'})
</ruby>

NOTE: Если попытаетесь запустить тест +test_should_create_post+ из +posts_controller_test.rb+, он провалится из-за недавно добавленной валидации на уровне модели, и это правильно.

Давайте изменим тест +test_should_create_post+ в +posts_controller_test.rb+ так, чтобы все наши тесты проходили:

<ruby>
test "should create post" do
  assert_difference('Post.count') do
    post :create, :post => { :title => 'Some title'}
  end

  assert_redirected_to post_path(assigns(:post))
end
</ruby>

Теперь можете попробовать запустить все тесты, и они должны пройти.

h4. Доступные типы запросов для функциональных тестов

Если вы знакомы с протоколом HTTP, то знаете, что +get+ это тип запроса. Имеется 6 типов запроса, поддерживаемых в функциональных тестах Rails:

* +get+
* +post+
* +patch+
* +put+
* +head+
* +delete+

Все типы запросов являются методами, которые можете использовать, однако, скорее всего, первые два вы будете использовать чаше остальных.

h4. The Four Hashes of the Apocalypse

После того, как запрос был сделан с использованием одного из 5 методов (+get+, +post+, и т.д.) и обработан, у Вас будет 4 объекта Hash, готовых для использования:

* +assigns+ - Любые объекты, хранящиеся как переменные экземпляров в экшнах для использования во вьюхах.
* +cookies+ - Любые установленные куки.
* +flash+ - Любые объекты, находящиеся во flash.
* +session+ - Любой объект, находящийся в переменных сессии.

Как и в случае с обычными объектами Hash, можете получать доступ к значениям, указав ключ в строке. Также можете указать его именем символа, кроме +assigns+. Например:

<ruby>
flash["gordon"]               flash[:gordon]
session["shmession"]          session[:shmession]
cookies["are_good_for_u"]     cookies[:are_good_for_u]

# Так как нельзя использовать assigns[:something] в силу исторических причин:
assigns["something"]          assigns(:something)
</ruby>

h4. Доступные переменные экземпляра

В Ваших функциональных тестах также доступны три переменные экземпляра:

* +@controller+ - Контроллер, обрабатывающий запрос
* +@request+ - Запрос
* +@response+ - Отклик

h4. Тестирование шаблонов и макетов

Если хотите убедиться, что отклик рендерит правильные шаблон и макет, можно использовать метод +assert_template+:

<ruby>
test "index should render correct template and layout" do
  get :index
  assert_template :index
  assert_template :layout => "layouts/application"
end
</ruby>

Отметьте, что нельзя тестировать шаблон и макет одновременно, в одном вызове метода +assert_template+. Также для тестирования +layout+ можно задать регулярное выражение вместо строки, но использование строки более точно описывает ситуацию. С другой стороны, следует включать имя директории "layouts" даже когда файл макета находится в этой стандартной директории для макетов. Следовательно,

<ruby>
assert_template :layout => "application"
</ruby>

не будет работать.

Если вьюха рендерит какой-либо партиал, при тестировании макета вы должны указать партиал в то же время. Иначе оператор контроля провалится.

Следовательно:

<ruby>
test "new should render correct layout" do
  get :new
  assert_template :layout => "layouts/application", :partial => "_form"
end
</ruby>

является правильным способом убедиться в правильности макета, когда вьюха рендерит партиал с именем +_form+. Если опустить ключ +:partial+ в вызове +assert_template+ он будет ругаться.

h4. Полноценный пример функционального теста

Вот другой пример, использующий +flash+, +assert_redirected_to+ и +assert_difference+:

<ruby>
test "should create post" do
  assert_difference('Post.count') do
    post :create, :post => { :title => 'Hi', :body => 'This is my first post.'}
  end
  assert_redirected_to post_path(assigns(:post))
  assert_equal 'Post was successfully created.', flash[:notice]
end
</ruby>

h4. Тестирование вьюх

Тестирование отклика на ваш запрос с помощью подтверждения наличия ключевых элементов HTML и их содержимого, это хороший способ протестировать вьюхи вашего приложения. Оператор контроля +assert_select+ позволяет осуществить это с помощью простого, но мощного синтаксиса.

NOTE: В другой документации вы можете обнаружить применение +assert_tag+, но сейчас он устарел в пользу +assert_select+.

Имеется две формы +assert_select+:

+assert_select(selector, [equality], [message])+ обеспечивает, что условие equality выполняется для выбранных через selector элементах. selector может быть выражением селектора CSS (String), выражением с заменяемыми значениями или объектом +HTML::Selector+.

+assert_select(element, selector, [equality], [message])+ обеспечивает, что условие equality выполняется для всех элементов, выбранных через selector начиная с _element_ (экземпляра +HTML::Node+) и его потомков.

Например, можете проверить содержимое в элементе title Вашего отклика с помощью:

<ruby>
assert_select 'title', "Welcome to Rails Testing Guide"
</ruby>

Также можно использовать вложенные блоки +assert_select+. В этом случае внутренний +assert_select+ запускает оператор контроля для полной коллекции элементов, выбранных во внешнем блоке +assert_select+:

<ruby>
assert_select 'ul.navigation' do
  assert_select 'li.menu_item'
end
</ruby>

Альтернативно, коллекция элементов, переданная внешним +assert_select+, может быть перебрана, таким образом +assert_select+ может быть вызван отдельно для каждого элемента. Предположим для примера, что отклик содержит два упорядоченных списка, каждый из четырех элементов, тогда оба следующих теста пройдут.

<ruby>
assert_select "ol" do |elements|
  elements.each do |element|
    assert_select element, "li", 4
  end
end

assert_select "ol" do
  assert_select "li", 8
end
</ruby>

Оператор контроля +assert_select+ достаточно мощный. Для более продвинутого использования обратитесь к его "документации":http://api.rubyonrails.org/classes/ActionController/Assertions/SelectorAssertions.html.

h5. Дополнительные операторы контроля, основанные на вьюхе

В тестировании вьюх в основном используется такие операторы контроля:

|_.Оператор контроля                                                                |_.Назначение|
|+assert_select_email+                                                              |Позволяет сделать утверждение относительно тела e-mail. |
|+assert_select_encoded+                                                            |Позволяет сделать утверждение относительно закодированного <span class="caps">HTML</span>. Он делает это декодируя содержимое каждого элемента и затем вызывая блок со всеми декодированными элементами.|
|+css_select(selector)+  or +css_select(element, selector)+                         |RВозвращают массив всех элементов, выбранных через _selector_. Во втором варианте сначала проверяется соответствие базовому _element_, а затем пытается применить соответствие выражению <em>selector</em> на каждом из его детей. Если нет соответствий, оба варианта возвращают пустой массив.|

Вот пример использования +assert_select_email+:

<ruby>
assert_select_email do
  assert_select 'small', 'Please click the "Unsubscribe" link if you want to opt-out.'
end
</ruby>
