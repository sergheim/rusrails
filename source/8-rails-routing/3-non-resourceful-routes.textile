h1. Нересурсные маршруты

В дополнению к ресурсному роутингу, Rails поддерживает роутинг произвольных URL к экшнам. Тут не будет групп маршрутов, создаваемых автоматически ресурсным роутингом. Вместо этого вы должны настроить каждый маршрут вашего приложения отдельно.

Хотя обычно следует пользоваться ресурсным роутингом, есть много мест, где более подходит простой роутинг. Не стоит пытаться заворачивать каждый кусочек своего приложения в ресурсные рамки, если он плохо поддается.

В частности, простой роутинг облегчает привязку унаследованых URL к новым экшнам Rails.

h4. Обязательные параметры

При настройке обычного маршрута вы предоставляете ряд символов, которые Rails связывает с частями входящего запроса HTTP. Два из этих символов специальные: +:controller+ связывает с именем контроллера в приложении, и +:action+ связывает с именем экшна в контроллере. Например, рассмотрим один из дефолтных маршрутов Rails:

<ruby>
get ':controller(/:action(/:id))'
</ruby>

Если входящий запрос +/photos/show/1+ обрабатывается этим маршрутом (так как не встретил какого-либо соответствующего маршрута в файле до этого), то результатом будет вызов экшна +show+ в +PhotosController+, и результирующий параметр (1) будет доступен как +params[:id]+. Этот маршрут также свяжет входящий запрос +/photos+ с +PhotosController+, поскольку +:action+ и +:id+ необязательные параметры, обозначенные скобками.

h4. Динамические сегменты

Можете настроить сколько угодно динамических сегментов в обычном маршруте. Всё, кроме +:controller+ или +:action+, будет доступно для соответствующего экшна как часть хэша params. Таким образом, если настроите такой маршрут:

<ruby>
get ':controller/:action/:id/:user_id'
</ruby>

Входящий URL +/photos/show/1/2+ будет направлен на экшн +show+ в +PhotosController+. +params[:id]+ будет установлен как "1", и +params[:user_id]+ будет установлен как "2".

NOTE: Нельзя использовать +:namespace+ или +:module+ вместе с сегментом пути +:controller+. Если это нужно, используйте ограничение на :controller, которое соответствует требуемому пространству имен, т.е.:

<ruby>
get ':controller(/:action(/:id))', :controller => /admin\/[^\/]+/
</ruby>

h4. Статичные сегменты

Можете определить статичные сегменты при создании маршрута:

<ruby>
get ':controller/:action/:id/with_user/:user_id'
</ruby>

Этот маршрут соответствует путям, таким как +/photos/show/1/with_user/2+. В этом случае +params+ будет <tt>{ :controller => "photos", :action => "show", :id => "1", :user_id => "2" }</tt>.

h4. Параметры строки запроса

+params+ также включает любые параметры из строки запроса. Например, с таким маршрутом:

<ruby>
get ':controller/:action/:id'
</ruby>

Входящий путь +/photos/show/1?user_id=2+ будет направлен на экшн +show+ контроллера +Photos+. +params+ будет <tt>{ :controller => "photos", :action => "show", :id => "1", :user_id => "2" }</tt>.

h4. Определение значений по умолчанию

В маршруте не обязательно явно использовать символы +:controller+ и +:action+. Можете предоставить их как значения по умолчанию:

<ruby>
get 'photos/:id' => 'photos#show'
</ruby>

С этим маршрутом Rails направит входящий путь +/photos/12+ на экшн +show+ в +PhotosController+.

Также можете определить другие значения по умолчанию в маршруте, предоставив хэш для опции +:defaults+. Это также относится к параметрам, которые не определены как динамические сегменты. Например:

<ruby>
get 'photos/:id' => 'photos#show', :defaults => { :format => 'jpg' }
</ruby>

Rails направит +photos/12+ в экшн +show+ +PhotosController+, и установит +params[:format]+ как +jpg+.

h4. Именование маршрутов

Можно определить имя для любого маршрута, используя опцию +:as+.

<ruby>
get 'exit' => 'sessions#destroy', :as => :logout
</ruby>

Это создаст +logout_path+ и +logout_url+ как именнованные хелперы в вашем приложении. Вызов +logout_path+ вернет +/exit+

Также это можно использовать для переопределения маршрутых методов, поределенных ресурсами, следующим образом:

<ruby>
get ':username', :to => "users#show", :as => :user
</ruby>

Что определит метод +user_path+, который будет доступен в контроллерах, хелперах и вьюхах, и будет вести на маршрут, такой как +/bob+. В экшне +show+ из +UsersController+, +params[:username]+ будет содержать имя пользователя. Измените +:username+ в определении маршурта, если не хотите, чтобы имя параметра было +:username+.

h4. Ограничения метода HTTP

В основном следует импользовать методы +get+, +post+, +put+ и +delete+ для ограничения маршрута определенным методом. Можно использовать метод +match+ с опцией +:via+ для соответствия нескольким методам за раз:

<ruby>
match 'photos' => 'photos#show', :via => [:get, :post]
</ruby>

Также можно установить соответствие всем методам для определенного маршрута, используя +:via => :all+:

<ruby>
match 'photos' => 'photos#show', :via => :all
</ruby>

Следует избегать маршрутизацию всех методов в экшн, если у вас нет веской причины делать так, поскольку маршрутизация запросов +GET+ и +POST+ одновременно в один экшн небезопасна.

h4. Ограничения сегмента

Можно использовать опцию +:constraints+ для соблюдения формата динамического сегмента:

<ruby>
get 'photos/:id' => 'photos#show', :constraints => { :id => /[A-Z]\d{5}/ }
</ruby>

Этот маршрут соответствует путям, таким как +/photos/A12345+. Можно выразить более кратко тот же маршрут следующим образом:

<ruby>
get 'photos/:id' => 'photos#show', :id => /[A-Z]\d{5}/
</ruby>

+:constraints+ принимает регулярное выражение c ограничением, что якоря regexp не могут использоваться. Например, следующий маршрут не работает:

<ruby>
get '/:id' => 'posts#show', :constraints => {:id => /^\d/}
</ruby>

Однако отметьте, что нет необходимости использовать якоря, поскольку все маршруты заякорены изначально.

Например, следующие маршруты приведут к +posts+ со значением +to_param+ такими как +1-hello-world+, которые всегда начинаются с цифры, к +users+ со значениями +to_param+ такими как +david+, никогда не начинающимися с цифры, разделенные в корневом пространстве имен:

<ruby>
get '/:id' => 'posts#show', :constraints => { :id => /\d.+/ }
get '/:username' => 'users#show'
</ruby>

h4. Ограничения, основанные на запросе

Также можно ограничить маршрут, основываясь на любом методе в объекте "Request":/action-controller-overview/the-request-and-response-objects, который возвращает +String+.

Ограничение, основанное на запросе, определяется так же, как и сегментное ограничение:

<ruby>
get "photos", :constraints => {:subdomain => "admin"}
</ruby>

Также можно определить ограничения в форме блока:

<ruby>
namespace :admin do
  constraints :subdomain => "admin" do
    resources :photos
  end
end
</ruby>

h4. Продвинутые ограничения

Если имеется более продвинутое ограничение, можете предоставить объект, отвечающий на +matches?+, который будет использовать Rails. Скажем, вы хотите направить всех пользователей через черный список в +BlacklistController+. Можно сделать так:

<ruby>
class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

TwitterClone::Application.routes.draw do
  get "*path" => "blacklist#index",
    :constraints => BlacklistConstraint.new
end
</ruby>

Ограничения также можно определить в форме блока:

<ruby>
namespace :admin do
  constraints :subdomain => "admin" do
    resources :photos
  end
end
</ruby>

h4. Подстановка маршрутов

Подстановка маршрутов - это способ указать, что определенные параметры должны соответствовать остальным частям маршрута. Например

<ruby>
get 'photos/*other' => 'photos#unknown'
</ruby>

Этот маршрут будет соответствовать +photos/12+ или +/photos/long/path/to/12+, установив +params[:other]+ как +"12"+, или +"long/path/to/12"+.

Динамические сегменты могут быть где угодно в маршруте. Например

<ruby>
get 'books/*section/:title' => 'books#show'
</ruby>

будет соответствовать +books/some/section/last-words-a-memoir+ с +params[:section]+ равным +"some/section"+, и +params[:title]+ равным +"last-words-a-memoir"+.

На самом деле технически маршрут может иметь более одного динамического сегмента, matcher назначает параметры интуитивным образом. Для примера

<ruby>
get '*a/foo/*b' => 'test#index'
</ruby>

будет соответствовать +zoo/woo/foo/bar/baz+ с +params[:a]+ равным +"zoo/woo"+, и +params[:b]+ равным +"bar/baz"+.

NOTE: Начиная с Rails 3.1, динамические маршруты всегда будут соответствовать опциональному формату сегмента по умолчанию. Например, если есть такой маршрут:

<ruby>
get '*pages' => 'pages#show'
</ruby>

NOTE: Запросив +"/foo/bar.json"+, ваш +params[:pages]+ будет равен +"foo/bar"+ с форматом запроса JSON. Если вам нужно вернуть старое поведение 3.0.x, можете предоставить +:format => false+ вот так:

<ruby>
get '*pages' => 'pages#show', :format => false
</ruby>

NOTE: Если хотите сделать сегмент формата обязательным, чтобы его нельзя было опустить, укажите +:format => true+ подобным образом:

<ruby>
get '*pages' => 'pages#show', :format => true
</ruby>

h4. Перенаправление

Можно перенаправить любой путь на другой путь, используя хелпер +redirect+ в вашем роутере:

<ruby>
get "/stories" => redirect("/posts")
</ruby>

Также можно повторно использовать динамические сегменты для соответствия пути, на который перенаправляем:

<ruby>
get "/stories/:name" => redirect("/posts/%{name}")
</ruby>

Также можно предоставить блок для перенаправления, который получает params и объект request:

<ruby>
get "/stories/:name" => redirect {|params, req| "/posts/#{params[:name].pluralize}" }
get "/stories" => redirect {|p, req| "/posts/#{req.subdomain}" }
</ruby>

Пожалуйста, отметьте, что это перенаправление является 301 "Moved Permanently". Учтите, что некоторые браузеры или прокси серверы закэшируют этот тип перенаправления, сделав старые страницы недоступными.

Во всех этих случаях, если не предоставить предшествующий хост (+http://www.example.com+), Rails возьмет эти детали из текущего запроса.

h4. Роутинг к приложениям Rack

Вместо строки, подобной +"posts#index"+, соответствующей экшну +index+ в +PostsController+, можно определить любое "приложение Rack":http://guides.rubyonrails.org/rails_on_rack.html как конечную точку совпадения.

<ruby>
match "/application.js" => Sprockets, :via => :all
</ruby>

Пока +Sprockets+ отвечает на +call+ и возвращает +[status, headers, body]+, роутер не будет различать приложение Rack и экшн. Здесь подходит использование +:via => :all+, если вы хотите позволить своему приложению Rack обрабатывать все методы так, как оно считает нужным.

NOTE: Для любопытства, +"posts#index"+ фактически расширяется до +PostsController.action(:index)+, который возвращает валидное приложение Rack.

h4. Использование +root+

Можно определить, с чем Rails должен связать +"/"+ с помощью метода +root+:

<ruby>
root :to => 'pages#main'
root 'pages#main' # то же самое в краткой форме
</ruby>

Следует поместить маршрут +root+ в начало файла, поскольку это наиболее популярный маршрут и должен быть проверен первым. Также необходимо удалить файл +public/index.html+, чтобы корневой маршрут заработал.

NOTE: Маршрут +root+ связывает с экшном только запросы +GET+.

h4. Маршруты с символами Unicode

Маршруты с символами unicode можно определять непосредственно. Например

<ruby>
match 'こんにちは' => 'welcome#index'
</ruby>
