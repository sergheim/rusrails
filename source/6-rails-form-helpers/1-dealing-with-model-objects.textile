h1. Работаем с объектами модели

h4. Хелперы объекта модели

Наиболее частыми задачами для форм являются редактирование или создание объекта модели. В то время как хелперы +*_tag+, конечно, могут быть использованы для этой задачи, они несколько многословны, так как для каждого тега вам придется обеспечить использование правильного имени параметра и установку подходящего значения поля по умолчанию. Rails предоставляет методы, подогнанные под эту задачу. У этих хелперов отсутствует суффикс _tag, например, +text_field+, +text_area+.

У этих хелперов первый аргумент -- это имя переменной экземпляра, а второй -- это имя метода (обычно атрибутного), вызываемого для этого объекта. Rails установит значение элемента управления равным возвращаемому значению метода объекта и установит подходящее имя поля. Если ваш контроллер определил +@person+ и имя этой персоны Henry, тогда форма, содержащая:

<erb>
<%= text_field(:person, :name) %>
</erb>

выдаст подобный результат

<erb>
<input id="person_name" name="person[name]" type="text" value="Henry"/>
</erb>

После подтверждения формы, значение, введенное пользователем, будет храниться в +params[:person][:name]+. Хэш +params[:person]+ годен для передачи в +Person.new+ или, если +@person+ - это экземпляр Person, в +@person.update_attributes+. Хотя имя атрибута -- очень распространенный второй параметр для этих хелперов, он не является обязательным. В вышеупомянутом примере, до тех пор пока объекты person имеют методы +name+ и +name=+, Rails будет удовлетворен.

WARNING: Необходимо передавать имя переменной экземпляра, т.е. +:person+ или +"person"+, а не фактический экземпляр объекта вашей модели.

Rails предоставляет хелперы для отображения ошибок валидации, связанных с объектом модели. Детально они раскрываются в руководстве "Отображение ошибок валидации во вьюхе":/active-record-validations-and-callbacks/displaying-validation-errors-in-the-view.

h4. Привязывание формы к объекту

Хотя комфортность несколько улучшилась, она еще далека от совершенства. Если у Person много атрибутов для редактирования, тогда мы должны повторить имя редактируемого объекта много раз. То, что мы хотим сделать, -- это как-то привязать форму к объекту модели, что как раз осуществляется с помощью +form_for+.

Допустим у нас есть контроллер для работы со статьями +articles_controller.rb+:

<ruby>
def new
  @article = Article.new
end
</ruby>

Соответствующая вьюха +articles/new.html.erb:+, использующая +form_for+, выглядит так

<erb>
<%= form_for @article, :url => { :action => "create" }, :html => {:class => "nifty_form"} do |f| %>
  <%= f.text_field :title %>
  <%= f.text_area :body, :size => "60x12" %>
  <%= f.submit "Create" %>
<% end %>
</erb>

Следует отметить несколько вещей:

# +@article+ -- это фактический объект, который редактируется.
# Здесь есть одиночный хэш опций. Опции маршрутизации передаются в хэше +:url+, опции HTML передаются в хэше +:html+. Также для формы можно предоставить опцию +:namespace+, чтобы быть уверенным в уникальности аттрибутов id элементов формы. Аттрибут namespace будет префиксом с подчеркиванием в генерируемых для HTML id.
# Метод +form_for+ предоставляет объект *form builder* (переменная +f+).
# Методы создания элементов управления формой вызываются *для* объекта form builder +f+

Итоговый HTML:

<html>
<form accept-charset="UTF-8" action="/articles/create" method="post" class="nifty_form">
  <input id="article_title" name="article[title]" type="text" />
  <textarea id="article_body" name="article[body]" cols="60" rows="12"></textarea>
  <input name="commit" type="submit" value="Create" />
</form>
</html>

Имя, переданное в +form_for+, контролирует ключ, используемый в +params+ для доступа к значениям формы. В примере имя +article+, и, таким образом, все поля формы имеют имена +article[<em>attribute_name</em>]+. Соответственно, в экшне +create+ хэш +params[:article]+ имеет ключи +:title+ и +:body+. О значимости имен полей ввода подробнее можно прочитать в разделе про имена параметров.

Методы хелпера, вызываемые из form builder, идентичны хелперам объекта модели, за исключением того, что не нужно указывать, какой объект будет редактироваться, так как это уже регулируется в form builder.

Можно создать подобное привязывание без фактического создания тега +&lt;form&gt;+ с помощью хелпера +fields_for+. Это полезно для редактирования дополнительных объектов модели в той же форме. Например, если имеем модель Person со связанной моделью ContactDetail, Вы можете создать форму для создания обеих моделей подобным образом:

<erb>
<%= form_for @person, :url => { :action => "create" } do |person_form| %>
  <%= person_form.text_field :name %>
  <%= fields_for @person.contact_detail do |contact_details_form| %>
    <%= contact_details_form.text_field :phone_number %>
  <% end %>
<% end %>
</erb>

которая выдаст такой результат:

<html>
<form accept-charset="UTF-8" action="/people/create" class="new_person" id="new_person" method="post">
  <input id="person_name" name="person[name]" type="text" />
  <input id="contact_detail_phone_number" name="contact_detail[phone_number]" type="text" />
</form>
</html>

Объект, предоставляемый +fields_for+, -- это form builder, подобный тому, который предоставляется +form_for+ (фактически +form_for+ внутри себя вызывает +fields_for+).

h4. Положитесь на идентификацию записи

Модель Article непосредственно доступна пользователям приложения, и таким образом, следуя лучшим рекомендациям разработки на Rails, вы должны объявить ее как *ресурс*.

<ruby>
resources :articles
</ruby>

TIP: Объявление ресурса имеет несколько побочных эффектов. Смотрите "Роутинг в Rails":/rails-routing для подробностей по настройке и использованию ресурсов.

Когда работаем с ресурсами RESTful, вызовы +form_for+ могут стать значительно проще, если их основывать на *идентификации записи*. Вкратце, вы должны всего лишь передать экземпляр модели и позволить Rails выяснить имя модели и остальное:

<ruby>
## Создание новой статьи
# длинный стиль:
form_for(@article, :url => articles_path)
# то же самое, короткий стиль (используется идентификация записи):
form_for(@article)

## Редактирование существующей статьи
# длинный стиль:
form_for(@article, :url => article_path(@article), :html => { :method => "patch" })
# короткий стиль:
form_for(@article)
</ruby>

Отметьте, как вызов короткого стиля +form_for+ остается тем же самым, независимо от того, будет запись новой или существующей. Идентификация записи достаточно сообразительная, чтобы выяснить, новая ли запись, запрашивая +record.new_record?+. Она также выбирает правильный путь для подтверждения и имя, основывающееся на классе объекта.

Rails также автоматически установит надлежащие атрибуты формы +class+ и +id+: форма, создающая статью, будет иметь +id+ и +class+ +new_article+. Если редактируется статья с id=23, то +class+ будет установлен как +edit_article+, и id - как +edit_article_23+. Эти атрибуты будут опускаться для краткости далее в этом руководстве.

WARNING: Когда используется STI (single-table inheritance, наследование с единой таблицей) с вашими моделями, нельзя полагаться на идентификацию записей субкласса, если лишь родительский класс определен ресурсом. Вы должны определить имя модели, +:url+ и +:method+ явно.

h5. Работаем с пространствами имен

Если вы создали пространство имен маршрутов, +form_for+ также можно изящно сократить. Если у приложения есть пространство имен admin, то

<ruby>
form_for [:admin, @article]
</ruby>

создаст форму, которая передается контроллеру статей в пространстве имен admin (передача в +admin_article_path(@article)+ в случае с обновлением). Если у вас несколько уровней пространства имен, тогда синтаксис подобный:

<ruby>
form_for [:admin, :management, @article]
</ruby>

Более подробно о системе маршрутизации Rails и связанным соглашениям смотрите "Роутинг в Rails":/rails-routing.

h4. Как формы работают с методами PATCH, PUT или DELETE?

Фреймворк Rails поддерживает дизайн RESTful в ваших приложениях, что означает частое использование запросов "PATCH" и "DELETE" (помимо "GET" и "POST"). Однако, большинство браузеров _не поддерживают_ методы, иные, чем "GET" и "POST", когда они исходят от подтверждаемых форм.

Rails работает с этой проблемой, эмулируя другие методы с помощью POST со скрытым полем, названным +"_method"+, который установлен для отражения желаемого метода:

<ruby>
form_tag(search_path, :method => "patch")
</ruby>

результат:

<html>
<form accept-charset="UTF-8" action="/search" method="post">
  <div style="margin:0;padding:0">
    <input name="_method" type="hidden" value="patch" />
    <input name="utf8" type="hidden" value="&#x2713;" />
    <input name="authenticity_token" type="hidden" value="f755bb0ed134b76c432144748a6d4b7a7ddf2b71" />
  </div>
  ...
</html>

При парсинге данных POST, Rails принимает в счет специальный параметр +_method+ и действует с ним, как будто бы был определен этот метод HTTP ("PATCH" в этом примере).
